# GC

## 什么是GC

1. GC，即Garbage Collection，垃圾回收，1960年，List语言使用了GC；
2. Java中GC的对象是堆内存和永久区

## GC算法

### 引用计数法

1. 是一种古老的垃圾回收算法；
2. 使用引用计算来回收垃圾；
3. Python使用

>引用计数法的实现很简单，给对象中添加一个引用计数器，每当一个地方引用这个对象时，计数值+1，当引用失效时，计数-1。任何时刻计数值为0表示这个对象不可能再被是使用。Java中没有使用这种算法。
>
>缺点：
>
>1. 引用和去引用时伴随加法和减法，影响性能；
>2. 很难处理对象间循环引用的问题；

### 标记-清除算法（Mark-Sweep）

1. 标记-清除算法是现代垃圾回收算法的思想基础。  

>标记-清除算法将垃圾回收分为两个阶段：
>
>1. 标记阶段：首先从根节点开始，标记所有从根结点开始的可达对象，未被标记的对象就是未被引用的垃圾对象；
>2. 清除阶段：清除所有未被标记的对象。
>
>缺点：
>
>1. 从效率的角度来看，标记和清除两个过程的效率都不高；
>2. 从空间的角度看，标记-清除后会产生大量不连续的内存碎片，内存碎片太多可能导致以后的程序运行过程中，需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发一次垃圾回收动作；

###　标记－整理算法（Mark-Compact）

1. 标记-压缩算法适合用于存放对象较多的场合，如老年代；
2. 它在标记-清除算法的基础上做了一些优化。和标记-清除算法一样，标记-压缩算法也首先从根节点开始，对所有可达对象做一次标记，但是之后，它会将所有的存活对象压缩到内存的一端，然后清理边界外的所有空间；

>标记-整理算法解决了标记-清除算法的内存碎片问题；

### 复制算法（Copying）

1. 复制算法是一种相对高效的算法；
2. 它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将这块内存中的存活对象复制到另外一块上面，然后将这块内存空间一次性清理掉，交换两块内存的角色，完成垃圾回收；

>优点：  
>每次只需要对整个半区进行垃圾回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针即可；  
>缺点：  
>内存浪费，每次只能使用一半空间；不适用于存活对象较多的场合，如老年代；

>现代的虚拟机一般使用复制算法来回收新生代，在虚拟机中，新生代内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor；每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和Survivor空间。Hotspot虚拟机默认Eden区和Survivor区的比例为8：1，也就是说每次新生代中可用的内存为整个新生代容量的90%，但是我们没法保证每次回收都只有不多于10%的对象存活，所以很有可能Survivor的空间不够用，这时候需要依赖老年代进行分配担保（Handle Promotion）。

##　分代收集
现代的商用虚拟机基本上都采用分代收集算法进行垃圾回收，也就是在上面几种算法在不同场合的结合；
根据对象的生命周期的不同将内存划分为几块，然后根据各块的特点采用最适合的收集算法；
大批量对象死去，少量对象存活的，使用复制算法。复制的成本低；对象存活率高，采用标记－整理算法或标记－清除算法。

## 概念整理

### 可触及性

所有的算法，都需要能够识别一个垃圾对象，这就需要弄清楚可触及性

可触及的：从根节点可以触及到这个对象；
不可触及的：在finalize()方法之后，对象可能会进入不可触及状态，不可触及的对象不可能被复活，不可触及的对象可以被回收；
可复活的：一个对象的所有对象都被释放，那这个对象就处于可复活状态，因为在finalize()中可能复活该对象（在该方法中建立对这个对象的引用），代码如下：

```java
public class CanReliveObj {
    public static CanReliveObj obj;
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("CanReliveObj finalize called");
        obj=this;
    }
    @Override
    public String toString(){
        return "I am CanReliveObj";
    }
}

public static void main(String[] args) throws InterruptedException{
    obj=new CanReliveObj();
    obj=null;   //可复活
    System.gc();
    Thread.sleep(1000);
    if(obj==null){
        System.out.println("obj 是 null");
    }else{
        System.out.println("obj 可用");
    }
    System.out.println("第二次gc");
    obj=null;    //不可复活
    System.gc();
    Thread.sleep(1000);
    if(obj==null){
        System.out.println("obj 是 null");
    }else{
        System.out.println("obj 可用");
    }
}
```

>注意，finalize方法只在GC前调用，且只会调用一次；应该避免使用finalize方法，因为该方法优先级低，且因为它由GC去调用，我们不知道什么时候会发生GC，所以不确定该方法可是会被调用，而且JVM不保证该方法一定会被调用。可以使用try-catch-finally来替代它。

### 根（GC Roots）

这些算法都是以根（GC Roots）为起点去搜索的；
Java中可以作为根的对象包括：

1. 虚拟机栈中引用的对象
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法区中JNI（即Native方法，本地方法）引用的对象